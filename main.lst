CCS PCH C Compiler, Version 5.116, 749               06-Dec-23 12:12

               Filename:   C:\Users\beadon\Documents\GitHub\circbuf_demo\main.lst

               ROM used:   1684 bytes (1%)
                           Largest free fragment is 65536
               RAM used:   405 (3%) at main() level
                           445 (3%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 126

*
00000:  GOTO   0534
*
00008:  MOVFF  500,504
0000C:  MOVFF  501,505
00010:  MOVFF  502,506
00014:  CLRF   507
00016:  MOVFF  503,508
0001A:  MOVLB  0
0001C:  MOVFF  4F5,509
00020:  MOVFF  4F6,50A
00024:  MOVFF  4F7,50B
00028:  MOVFF  4F8,50C
0002C:  BTFSS  4A2.0
0002E:  GOTO   0038
00032:  BTFSC  4B2.0
00034:  GOTO   0072
00038:  MOVFF  509,4F5
0003C:  MOVFF  50A,4F6
00040:  MOVFF  50B,4F7
00044:  MOVFF  50C,4F8
00048:  MOVFF  504,500
0004C:  MOVFF  505,501
00050:  MOVFF  506,502
00054:  BSF    507.7
00056:  MOVFF  508,503
0005A:  RETFIE 1
.................... #include <main.h>
.................... #include <18F57Q84.h>
.................... //////////// Standard Header file for the PIC18F57Q84 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
*
000AC:  BCF    4B2.0
000AE:  MOVLB  0
000B0:  GOTO   0038
.................... #device PIC18F57Q84
*
0005C:  CLRF   4F7
0005E:  ADDLW  70
00060:  MOVWF  4F6
00062:  MOVLW  00
00064:  ADDWFC 4F7,F
00066:  MOVLW  00
00068:  MOVWF  4F8
0006A:  TBLRD*+
0006C:  MOVF   4F5,W
0006E:  RETURN 0
00070:  DATA 25,05
00072:  MOVLW  05
00074:  MOVWF  4EA
00076:  MOVLW  1D
00078:  MOVWF  4E9
0007A:  MOVF   51F,W
0007C:  ADDWF  4E9,F
0007E:  MOVLW  00
00080:  ADDWFC 4EA,F
00082:  MOVLB  2
00084:  MOVFF  2B2,521
00088:  MOVFF  2A1,4EF
0008C:  BTFSS  521.1
0008E:  BRA    0098
00090:  BCF    xAB.4
00092:  BSF    xB0.1
00094:  BCF    xB2.1
00096:  BSF    xAB.4
00098:  INCF   51F,F
0009A:  MOVLW  01
0009C:  BSF    4D8.0
0009E:  SUBFWB 51F,W
000A0:  BC    00A4
000A2:  CLRF   51F
000A4:  MOVF   520,W
000A6:  SUBWF  51F,W
000A8:  BNZ   00AC
000AA:  BSF    523.1
*
000B4:  MOVLB  6
000B6:  MOVF   xBB,W
000B8:  CLRF   501
000BA:  SUBWF  xBA,W
000BC:  BC    00C4
000BE:  MOVFF  6BA,500
000C2:  BRA    00DC
000C4:  CLRF   500
000C6:  MOVLW  08
000C8:  MOVWF  xBC
000CA:  RLCF   xBA,F
000CC:  RLCF   500,F
000CE:  MOVF   xBB,W
000D0:  SUBWF  500,W
000D2:  BTFSC  4D8.0
000D4:  MOVWF  500
000D6:  RLCF   501,F
000D8:  DECFSZ xBC,F
000DA:  BRA    00CA
000DC:  MOVLB  0
000DE:  RETURN 0
*
00234:  TBLRD*+
00236:  MOVF   4F5,F
00238:  BZ    0260
0023A:  MOVFF  4F6,6AB
0023E:  MOVFF  4F7,6AC
00242:  MOVFF  4F8,6AD
00246:  MOVF   4F5,W
00248:  BTFSS  4B2.1
0024A:  BRA    0248
0024C:  MOVLB  2
0024E:  MOVWF  xA3
00250:  MOVFF  6AB,4F6
00254:  MOVFF  6AC,4F7
00258:  MOVFF  6AD,4F8
0025C:  MOVLB  0
0025E:  BRA    0234
00260:  RETURN 0
*
003B0:  TBLRD*+
003B2:  MOVFF  4F6,6AC
003B6:  MOVFF  4F7,6AD
003BA:  MOVFF  4F8,6AE
003BE:  MOVF   4F5,W
003C0:  BTFSS  4B2.1
003C2:  BRA    03C0
003C4:  MOVLB  2
003C6:  MOVWF  xA3
003C8:  MOVFF  6AC,4F6
003CC:  MOVFF  6AD,4F7
003D0:  MOVFF  6AE,4F8
003D4:  MOVLB  6
003D6:  DECFSZ xAB,F
003D8:  BRA    03DC
003DA:  BRA    03E0
003DC:  MOVLB  0
003DE:  BRA    03B0
003E0:  MOVLB  0
003E2:  RETURN 0
003E4:  MOVLB  6
003E6:  BTFSC  xAC.7
003E8:  BRA    040E
003EA:  MOVLW  0F
003EC:  MOVWF  500
003EE:  SWAPF  xAB,W
003F0:  ANDWF  500,F
003F2:  MOVLW  0A
003F4:  SUBWF  500,W
003F6:  BC    03FE
003F8:  MOVLW  30
003FA:  ADDWF  500,F
003FC:  BRA    0402
003FE:  MOVF   xAC,W
00400:  ADDWF  500,F
00402:  MOVF   500,W
00404:  BTFSS  4B2.1
00406:  BRA    0404
00408:  MOVLB  2
0040A:  MOVWF  xA3
0040C:  MOVLB  6
0040E:  MOVLW  0F
00410:  ANDWF  xAB,F
00412:  MOVLW  0A
00414:  SUBWF  xAB,W
00416:  BC    041C
00418:  MOVLW  30
0041A:  BRA    0420
0041C:  BCF    xAC.7
0041E:  MOVF   xAC,W
00420:  ADDWF  xAB,F
00422:  MOVF   xAB,W
00424:  BTFSS  4B2.1
00426:  BRA    0424
00428:  MOVLB  2
0042A:  MOVWF  xA3
0042C:  MOVLB  0
0042E:  RETURN 0
*
004FA:  DATA 4F,75
004FC:  DATA 74,20
004FE:  DATA 6F,66
00500:  DATA 20,73
00502:  DATA 70,61
00504:  DATA 63,65
00506:  DATA 20,69
00508:  DATA 6E,20
0050A:  DATA 43,42
0050C:  DATA 0A,00
0050E:  DATA 43,42
00510:  DATA 20,69
00512:  DATA 73,20
00514:  DATA 65,6D
00516:  DATA 70,74
00518:  DATA 79,0A
0051A:  DATA 00,00
0051C:  DATA 50,75
0051E:  DATA 73,68
00520:  DATA 3A,20
00522:  DATA 30,78
00524:  DATA 25,78
00526:  DATA 0A,00
00528:  DATA 50,6F
0052A:  DATA 70,3A
0052C:  DATA 20,20
0052E:  DATA 30,78
00530:  DATA 25,78
00532:  DATA 0A,00
.................... 
.................... #list
.................... 
.................... #device ADC=12
.................... 
.................... #FUSES NOWDT                    //No Watch Dog Timer
.................... 
.................... #use delay(internal=64MHz)
.................... 
.................... #define LED PIN_F0
.................... 
.................... 
.................... 
.................... #include <stdio.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDIO
.................... #define _STDIO
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #ifndef getc
.................... #define getc getch
.................... #define getchar getch
.................... #define puts(s) {printf(s); putchar(13); putchar(10);}
.................... #define putc putchar
.................... #endif
.................... /* maps error number to an error message. Writes a sequence of characters to
.................... stderr stream thus: if s is not null then string pointed to by s follwed by
.................... a colon (:) and a space and the appropriate error message returned by strerror
.................... function with argument errno
.................... 
.................... Returns: no value
.................... */
.................... 
.................... #ifdef _ERRNO
.................... void perror(char *s)
.................... {
....................   if(s)
....................   fprintf(STDERR,"%s: ",s);
....................   fprintf(STDERR,"%s\r\n",strerror(errno));
.................... }
.................... #endif
.................... #endif
.................... 
.................... #include <stdint.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                           stdint.h                                ////
.................... ////                                                                   ////
.................... //// Standard integer definitions.                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDINT
.................... 
.................... #define _STDINT
.................... 
.................... //////////// exact width
.................... 
.................... typedef signed int8 int8_t;
.................... typedef unsigned int8 uint8_t;
.................... typedef signed int16 int16_t;
.................... typedef unsigned int16 uint16_t;
.................... typedef signed int32 int32_t;
.................... typedef unsigned int32 uint32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int24_t;
.................... //typedef unsigned int24 uint24_t;
.................... typedef signed int64 int64_t;
.................... typedef unsigned int64 uint64_t;
.................... #endif
.................... 
.................... #define INT8_MAX  (127)
.................... #define INT8_MIN  (-128)
.................... #define UINT8_MAX (255)
.................... 
.................... #define INT16_MAX  (32767)
.................... #define INT16_MIN  (-32768)
.................... #define UINT16_MAX (65535)
.................... 
.................... #define INT32_MAX  (2147483647)
.................... #define INT32_MIN  (-2147483648)
.................... #define UINT32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT24_MAX  (8388607)
.................... //#define INT24_MIN  (-8388608)
.................... //#define UINT24_MAX (16777215)
.................... 
.................... #define INT64_MAX  (9223372036854775807)
.................... #define INT64_MIN  (-9223372036854775808)
.................... #define UINT64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// minimum width
.................... 
.................... typedef signed int8 int_least8_t;
.................... typedef unsigned int8 uint_least8_t;
.................... typedef signed int16 int_least16_t;
.................... typedef unsigned int16 uint_least16_t;
.................... typedef signed int32 int_least32_t;
.................... typedef unsigned int32 uint_least32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int_least24_t;
.................... //typedef unsigned int24 uint_least24_t;
.................... typedef signed int64 int_least64_t;
.................... typedef unsigned int64 uint_least64_t;
.................... #endif
.................... 
.................... #define INT_LEAST8_MAX  (127)
.................... #define INT_LEAST8_MIN  (-128)
.................... #define UINT_LEAST8_MAX (255)
.................... 
.................... #define INT_LEAST16_MAX  (32767)
.................... #define INT_LEAST16_MIN  (-32768)
.................... #define UINT_LEAST16_MAX (65535)
.................... 
.................... #define INT_LEAST32_MAX  (2147483647)
.................... #define INT_LEAST32_MIN  (-2147483648)
.................... #define UINT_LEAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_LEAST24_MAX  (8388607)
.................... //#define INT_LEAST24_MIN  (-8388608)
.................... //#define UINT_LEAST24_MAX (16777215)
.................... 
.................... #define INT_LEAST64_MAX  (9223372036854775807)
.................... #define INT_LEAST64_MIN  (-9223372036854775808)
.................... #define UINT_LEAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// fastest width
.................... 
.................... #if defined(__PCD__)
.................... typedef signed int16 int_fast8_t;
.................... typedef unsigned int16 uint_fast8_t;
.................... #define INT_FAST8_MAX  (32767)
.................... #define INT_FAST8_MIN  (-32768)
.................... #define UINT_FAST8_MAX (65535)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... //typedef signed int24 int_fast24_t;
.................... //typedef unsigned int24 uint_fast24_t;
.................... typedef signed int64 int_fast64_t;
.................... typedef unsigned int64 uint_fast64_t;
.................... #else
.................... typedef signed int8 int_fast8_t;
.................... typedef unsigned int8 uint_fast8_t;
.................... #define INT_FAST8_MAX  (127)
.................... #define INT_FAST8_MIN  (-128)
.................... #define UINT_FAST8_MAX (255)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... #endif
.................... 
.................... typedef signed int32 int_fast32_t;
.................... typedef unsigned int32 uint_fast32_t;
.................... 
.................... #define INT_FAST16_MAX  (32767)
.................... #define INT_FAST16_MIN  (-32768)
.................... #define UINT_FAST16_MAX (65535)
.................... 
.................... #define INT_FAST32_MAX  (2147483647)
.................... #define INT_FAST32_MIN  (-2147483648)
.................... #define UINT_FAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_FAST24_MAX  (8388607)
.................... //#define INT_FAST24_MIN  (-8388608)
.................... //#define UINT_FAST24_MAX (16777215)
.................... 
.................... #define INT_FAST64_MAX  (9223372036854775807)
.................... #define INT_FAST64_MIN  (-9223372036854775808)
.................... #define UINT_FAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... //////////// big enough to hold pointers (OPTIONAL)
.................... 
.................... #if defined(__PCD__)
....................    typedef unsigned int32 uintptr_t;
....................    typedef signed int32 intptr_t;
.................... #else
....................    typedef unsigned int16 uintptr_t;
....................    typedef signed int16 intptr_t;
.................... #endif
.................... 
.................... #define INT8_C(val) ((int8_t)val)
.................... #define UINT8_C(val) ((uint8_t)val)
.................... #define INT16_C(val) ((int16_t)val)
.................... #define UINT16_C(val) ((uint16_t)val)
.................... #define INT32_C(val) ((int32_t)val)
.................... #define UINT32_C(val) ((uint32_t)val)
.................... 
.................... #if defined(__PCD__)
.................... #define INT64_C(val) ((int64_t)val)
.................... #define UINT64_C(val) ((uint64_t)val)
.................... #endif
.................... 
.................... /// TODO:
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX
.................... 
.................... 
.................... /////////// greatest width (OPTIONAL)
.................... 
.................... #ifdef __PCD__
....................    typedef signed int64 intmax_t;
....................    typedef unsigned int64 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (9223372036854775807)
....................    #define INTMAXN_MIN  (-9223372036854775808)
....................    #define UINTMAXN_MAX (18446744073709551615)
....................    
....................    #define INTMAX_C(value) ((signed int64)val)
....................    #define UINTMAX_C(value) ((unsigned int64)val)
.................... #else
....................    typedef signed int32 intmax_t;
....................    typedef unsigned int32 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (2147483647)
....................    #define INTMAXN_MIN  (-2147483648)
....................    #define UINTMAXN_MAX (4294967295)
....................    
....................    #define INTMAX_C(value) ((signed int32)val)
....................    #define UINTMAX_C(value) ((unsigned int32)val)
.................... #endif
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... typedef struct {
....................     uint8_t can_header;
....................     uint8_t data[8];
....................     uint8_t errors;
....................     uint8_t counter;
.................... } can_rx_frame_t;
.................... 
.................... #include "circbuf.h"
.................... /*
....................  * Copyright (c) 2020-2021 Siddharth Chandrasekaran <sidcha.dev@gmail.com>
....................  *
....................  * SPDX-License-Identifier: Apache-2.0
....................  */
.................... 
.................... #ifndef _UTIL_CIRCBUF_H_
.................... #define _UTIL_CIRCBUF_H_
.................... 
.................... #include <stdint.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                           stdint.h                                ////
.................... ////                                                                   ////
.................... //// Standard integer definitions.                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDINT
.................... 
.................... #define _STDINT
.................... 
.................... //////////// exact width
.................... 
.................... typedef signed int8 int8_t;
.................... typedef unsigned int8 uint8_t;
.................... typedef signed int16 int16_t;
.................... typedef unsigned int16 uint16_t;
.................... typedef signed int32 int32_t;
.................... typedef unsigned int32 uint32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int24_t;
.................... //typedef unsigned int24 uint24_t;
.................... typedef signed int64 int64_t;
.................... typedef unsigned int64 uint64_t;
.................... #endif
.................... 
.................... #define INT8_MAX  (127)
.................... #define INT8_MIN  (-128)
.................... #define UINT8_MAX (255)
.................... 
.................... #define INT16_MAX  (32767)
.................... #define INT16_MIN  (-32768)
.................... #define UINT16_MAX (65535)
.................... 
.................... #define INT32_MAX  (2147483647)
.................... #define INT32_MIN  (-2147483648)
.................... #define UINT32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT24_MAX  (8388607)
.................... //#define INT24_MIN  (-8388608)
.................... //#define UINT24_MAX (16777215)
.................... 
.................... #define INT64_MAX  (9223372036854775807)
.................... #define INT64_MIN  (-9223372036854775808)
.................... #define UINT64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// minimum width
.................... 
.................... typedef signed int8 int_least8_t;
.................... typedef unsigned int8 uint_least8_t;
.................... typedef signed int16 int_least16_t;
.................... typedef unsigned int16 uint_least16_t;
.................... typedef signed int32 int_least32_t;
.................... typedef unsigned int32 uint_least32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int_least24_t;
.................... //typedef unsigned int24 uint_least24_t;
.................... typedef signed int64 int_least64_t;
.................... typedef unsigned int64 uint_least64_t;
.................... #endif
.................... 
.................... #define INT_LEAST8_MAX  (127)
.................... #define INT_LEAST8_MIN  (-128)
.................... #define UINT_LEAST8_MAX (255)
.................... 
.................... #define INT_LEAST16_MAX  (32767)
.................... #define INT_LEAST16_MIN  (-32768)
.................... #define UINT_LEAST16_MAX (65535)
.................... 
.................... #define INT_LEAST32_MAX  (2147483647)
.................... #define INT_LEAST32_MIN  (-2147483648)
.................... #define UINT_LEAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_LEAST24_MAX  (8388607)
.................... //#define INT_LEAST24_MIN  (-8388608)
.................... //#define UINT_LEAST24_MAX (16777215)
.................... 
.................... #define INT_LEAST64_MAX  (9223372036854775807)
.................... #define INT_LEAST64_MIN  (-9223372036854775808)
.................... #define UINT_LEAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// fastest width
.................... 
.................... #if defined(__PCD__)
.................... typedef signed int16 int_fast8_t;
.................... typedef unsigned int16 uint_fast8_t;
.................... #define INT_FAST8_MAX  (32767)
.................... #define INT_FAST8_MIN  (-32768)
.................... #define UINT_FAST8_MAX (65535)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... //typedef signed int24 int_fast24_t;
.................... //typedef unsigned int24 uint_fast24_t;
.................... typedef signed int64 int_fast64_t;
.................... typedef unsigned int64 uint_fast64_t;
.................... #else
.................... typedef signed int8 int_fast8_t;
.................... typedef unsigned int8 uint_fast8_t;
.................... #define INT_FAST8_MAX  (127)
.................... #define INT_FAST8_MIN  (-128)
.................... #define UINT_FAST8_MAX (255)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... #endif
.................... 
.................... typedef signed int32 int_fast32_t;
.................... typedef unsigned int32 uint_fast32_t;
.................... 
.................... #define INT_FAST16_MAX  (32767)
.................... #define INT_FAST16_MIN  (-32768)
.................... #define UINT_FAST16_MAX (65535)
.................... 
.................... #define INT_FAST32_MAX  (2147483647)
.................... #define INT_FAST32_MIN  (-2147483648)
.................... #define UINT_FAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_FAST24_MAX  (8388607)
.................... //#define INT_FAST24_MIN  (-8388608)
.................... //#define UINT_FAST24_MAX (16777215)
.................... 
.................... #define INT_FAST64_MAX  (9223372036854775807)
.................... #define INT_FAST64_MIN  (-9223372036854775808)
.................... #define UINT_FAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... //////////// big enough to hold pointers (OPTIONAL)
.................... 
.................... #if defined(__PCD__)
....................    typedef unsigned int32 uintptr_t;
....................    typedef signed int32 intptr_t;
.................... #else
....................    typedef unsigned int16 uintptr_t;
....................    typedef signed int16 intptr_t;
.................... #endif
.................... 
.................... #define INT8_C(val) ((int8_t)val)
.................... #define UINT8_C(val) ((uint8_t)val)
.................... #define INT16_C(val) ((int16_t)val)
.................... #define UINT16_C(val) ((uint16_t)val)
.................... #define INT32_C(val) ((int32_t)val)
.................... #define UINT32_C(val) ((uint32_t)val)
.................... 
.................... #if defined(__PCD__)
.................... #define INT64_C(val) ((int64_t)val)
.................... #define UINT64_C(val) ((uint64_t)val)
.................... #endif
.................... 
.................... /// TODO:
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX
.................... 
.................... 
.................... /////////// greatest width (OPTIONAL)
.................... 
.................... #ifdef __PCD__
....................    typedef signed int64 intmax_t;
....................    typedef unsigned int64 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (9223372036854775807)
....................    #define INTMAXN_MIN  (-9223372036854775808)
....................    #define UINTMAXN_MAX (18446744073709551615)
....................    
....................    #define INTMAX_C(value) ((signed int64)val)
....................    #define UINTMAX_C(value) ((unsigned int64)val)
.................... #else
....................    typedef signed int32 intmax_t;
....................    typedef unsigned int32 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (2147483647)
....................    #define INTMAXN_MIN  (-2147483648)
....................    #define UINTMAXN_MAX (4294967295)
....................    
....................    #define INTMAX_C(value) ((signed int32)val)
....................    #define UINTMAX_C(value) ((unsigned int32)val)
.................... #endif
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... /** --- Internal methods and structures. DON'T USE --------------------------- */
.................... typedef struct {
....................    void * buffer;
....................    int push_count;
....................    int pop_count;
....................    int size;
....................    int element_size;
.................... } circbuf_t;
.................... 
.................... #define __CIRCBUF_VAR_DEF(type, buf, sz)  \
....................    type buf ## _circbuf_data[sz];         \
....................    circbuf_t buf= {              \
....................       buf ## _circbuf_data,      \
....................       0,                         \
....................       0,                         \
....................       sz,                        \
....................       sizeof(type)               \
....................    };
.................... 
.................... //!#define __CIRCBUF_VAR_DEF(type, buf, sz)      \
.................... //!   type buf ## _circbuf_data[sz];         \
.................... //!   circbuf_t buf= {            \
.................... //!      .buffer = buf ## _circbuf_data,      \
.................... //!      .push_count = 0,         \
.................... //!      .pop_count = 0,            \
.................... //!      .size = sz,            \
.................... //!      .element_size = sizeof(type)      \
.................... //!   };
.................... //!
.................... 
.................... int __circbuf_push(circbuf_t *circbuf, void *elem);
.................... int __circbuf_pop (circbuf_t *circbuf, void *elem, int read_only);
.................... int __circbuf_free_space(circbuf_t *circbuf);
.................... /* -------------------------------------------------------------------------- */
.................... 
.................... /**
....................  * Description:
....................  *   Zero slots in circular buffer after a pop.
....................  */
.................... // #define CIRCBUF_CLEAN_ON_POP
.................... 
.................... /**
....................  * Description:
....................  *   Defines a global circular buffer `buf` of a given type and size. The type
....................  *   can be native data types or user-defined data types.
....................  *
....................  * Usage:
....................  *   CIRCBUF_DEF(uint8_t, byte_buf, 13);
....................  *   CIRCBUF_DEF(struct foo, foo_buf, 10);
....................  */
.................... #define CIRCBUF_DEF(type, buf, size)         \
....................    __CIRCBUF_VAR_DEF(type, buf, size)      \
....................    int buf ## _push_refd(type *pt)         \
....................    {                  \
....................       return __circbuf_push(&buf, pt);   \
....................    }                  \
....................    int buf ## _pop_refd(type *pt)         \
....................    {                  \
....................       return __circbuf_pop(&buf, pt, 0);   \
....................    }                  \
....................    int buf ## _peek_refd(type *pt)         \
....................    {                  \
....................       return __circbuf_pop(&buf, pt, 1);   \
....................    }
.................... 
.................... /**
....................  * Description:
....................  *   Resets the circular buffer offsets to zero. Does not clean the newly freed
....................  *   slots.
....................  */
.................... #define CIRCBUF_FLUSH(buf)            \
....................    do {                  \
....................       buf.push_count = 0;         \
....................       buf.pop_count = 0;         \
....................    } while(0)
.................... 
.................... /**
....................  * Description:
....................  *   Pushes element pointed to by `elem` at the head of circular buffer `buf`.
....................  *   This is read-write method, occupancy count increases by one.
....................  *
....................  * Returns (int):
....................  *   0 - Success
....................  *  -1 - Out of space
....................  */
.................... #define CIRCBUF_PUSH(buf, elem)             buf ## _push_refd(elem)
.................... 
.................... /**
....................  * Description:
....................  *   Copies the element at tail of circular buffer `buf` into location pointed
....................  *   by `elem`. This method is read-only, does not alter occupancy status.
....................  *
....................  * Returns (int):
....................  *   0 - Success
....................  *  -1 - Empty
....................  */
.................... #define CIRCBUF_PEEK(buf, elem)             buf ## _peek_refd(elem)
.................... 
.................... /**
....................  * Description:
....................  *   Removes the element at tail from circular buffer `buf` and makes it
....................  *   available at `elem`. This is read-write method, occupancy count reduces
....................  *   by one.
....................  *
....................  * Returns (int):
....................  *   0 - Success
....................  *  -1 - Empty
....................  */
.................... #define CIRCBUF_POP(buf, elem)              buf ## _pop_refd(elem)
.................... 
.................... /**
....................  * Description:
....................  *   Returns the number of free slots in the circular buffer `buf`.
....................  *
....................  * Returns (int):
....................  *   0..N - number of slots available.
....................  */
.................... #define CIRCBUF_FS(buf)                     __circbuf_free_space(&buf)
.................... 
.................... #endif /* _UTIL_CIRCBUF_H_ */
.................... 
.................... #include "circbuf.c"
.................... /*
....................  * Copyright (c) 2020-2021 Siddharth Chandrasekaran <sidcha.dev@gmail.com>
....................  *
....................  * SPDX-License-Identifier: Apache-2.0
....................  */
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include <stdint.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                           stdint.h                                ////
.................... ////                                                                   ////
.................... //// Standard integer definitions.                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDINT
.................... 
.................... #define _STDINT
.................... 
.................... //////////// exact width
.................... 
.................... typedef signed int8 int8_t;
.................... typedef unsigned int8 uint8_t;
.................... typedef signed int16 int16_t;
.................... typedef unsigned int16 uint16_t;
.................... typedef signed int32 int32_t;
.................... typedef unsigned int32 uint32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int24_t;
.................... //typedef unsigned int24 uint24_t;
.................... typedef signed int64 int64_t;
.................... typedef unsigned int64 uint64_t;
.................... #endif
.................... 
.................... #define INT8_MAX  (127)
.................... #define INT8_MIN  (-128)
.................... #define UINT8_MAX (255)
.................... 
.................... #define INT16_MAX  (32767)
.................... #define INT16_MIN  (-32768)
.................... #define UINT16_MAX (65535)
.................... 
.................... #define INT32_MAX  (2147483647)
.................... #define INT32_MIN  (-2147483648)
.................... #define UINT32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT24_MAX  (8388607)
.................... //#define INT24_MIN  (-8388608)
.................... //#define UINT24_MAX (16777215)
.................... 
.................... #define INT64_MAX  (9223372036854775807)
.................... #define INT64_MIN  (-9223372036854775808)
.................... #define UINT64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// minimum width
.................... 
.................... typedef signed int8 int_least8_t;
.................... typedef unsigned int8 uint_least8_t;
.................... typedef signed int16 int_least16_t;
.................... typedef unsigned int16 uint_least16_t;
.................... typedef signed int32 int_least32_t;
.................... typedef unsigned int32 uint_least32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int_least24_t;
.................... //typedef unsigned int24 uint_least24_t;
.................... typedef signed int64 int_least64_t;
.................... typedef unsigned int64 uint_least64_t;
.................... #endif
.................... 
.................... #define INT_LEAST8_MAX  (127)
.................... #define INT_LEAST8_MIN  (-128)
.................... #define UINT_LEAST8_MAX (255)
.................... 
.................... #define INT_LEAST16_MAX  (32767)
.................... #define INT_LEAST16_MIN  (-32768)
.................... #define UINT_LEAST16_MAX (65535)
.................... 
.................... #define INT_LEAST32_MAX  (2147483647)
.................... #define INT_LEAST32_MIN  (-2147483648)
.................... #define UINT_LEAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_LEAST24_MAX  (8388607)
.................... //#define INT_LEAST24_MIN  (-8388608)
.................... //#define UINT_LEAST24_MAX (16777215)
.................... 
.................... #define INT_LEAST64_MAX  (9223372036854775807)
.................... #define INT_LEAST64_MIN  (-9223372036854775808)
.................... #define UINT_LEAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// fastest width
.................... 
.................... #if defined(__PCD__)
.................... typedef signed int16 int_fast8_t;
.................... typedef unsigned int16 uint_fast8_t;
.................... #define INT_FAST8_MAX  (32767)
.................... #define INT_FAST8_MIN  (-32768)
.................... #define UINT_FAST8_MAX (65535)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... //typedef signed int24 int_fast24_t;
.................... //typedef unsigned int24 uint_fast24_t;
.................... typedef signed int64 int_fast64_t;
.................... typedef unsigned int64 uint_fast64_t;
.................... #else
.................... typedef signed int8 int_fast8_t;
.................... typedef unsigned int8 uint_fast8_t;
.................... #define INT_FAST8_MAX  (127)
.................... #define INT_FAST8_MIN  (-128)
.................... #define UINT_FAST8_MAX (255)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... #endif
.................... 
.................... typedef signed int32 int_fast32_t;
.................... typedef unsigned int32 uint_fast32_t;
.................... 
.................... #define INT_FAST16_MAX  (32767)
.................... #define INT_FAST16_MIN  (-32768)
.................... #define UINT_FAST16_MAX (65535)
.................... 
.................... #define INT_FAST32_MAX  (2147483647)
.................... #define INT_FAST32_MIN  (-2147483648)
.................... #define UINT_FAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_FAST24_MAX  (8388607)
.................... //#define INT_FAST24_MIN  (-8388608)
.................... //#define UINT_FAST24_MAX (16777215)
.................... 
.................... #define INT_FAST64_MAX  (9223372036854775807)
.................... #define INT_FAST64_MIN  (-9223372036854775808)
.................... #define UINT_FAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... //////////// big enough to hold pointers (OPTIONAL)
.................... 
.................... #if defined(__PCD__)
....................    typedef unsigned int32 uintptr_t;
....................    typedef signed int32 intptr_t;
.................... #else
....................    typedef unsigned int16 uintptr_t;
....................    typedef signed int16 intptr_t;
.................... #endif
.................... 
.................... #define INT8_C(val) ((int8_t)val)
.................... #define UINT8_C(val) ((uint8_t)val)
.................... #define INT16_C(val) ((int16_t)val)
.................... #define UINT16_C(val) ((uint16_t)val)
.................... #define INT32_C(val) ((int32_t)val)
.................... #define UINT32_C(val) ((uint32_t)val)
.................... 
.................... #if defined(__PCD__)
.................... #define INT64_C(val) ((int64_t)val)
.................... #define UINT64_C(val) ((uint64_t)val)
.................... #endif
.................... 
.................... /// TODO:
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX
.................... 
.................... 
.................... /////////// greatest width (OPTIONAL)
.................... 
.................... #ifdef __PCD__
....................    typedef signed int64 intmax_t;
....................    typedef unsigned int64 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (9223372036854775807)
....................    #define INTMAXN_MIN  (-9223372036854775808)
....................    #define UINTMAXN_MAX (18446744073709551615)
....................    
....................    #define INTMAX_C(value) ((signed int64)val)
....................    #define UINTMAX_C(value) ((unsigned int64)val)
.................... #else
....................    typedef signed int32 intmax_t;
....................    typedef unsigned int32 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (2147483647)
....................    #define INTMAXN_MIN  (-2147483648)
....................    #define UINTMAXN_MAX (4294967295)
....................    
....................    #define INTMAX_C(value) ((signed int32)val)
....................    #define UINTMAX_C(value) ((unsigned int32)val)
.................... #endif
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "circbuf.h"
.................... /*
....................  * Copyright (c) 2020-2021 Siddharth Chandrasekaran <sidcha.dev@gmail.com>
....................  *
....................  * SPDX-License-Identifier: Apache-2.0
....................  */
.................... 
.................... #ifndef _UTIL_CIRCBUF_H_
.................... #define _UTIL_CIRCBUF_H_
.................... 
.................... #include <stdint.h>
.................... 
.................... /** --- Internal methods and structures. DON'T USE --------------------------- */
.................... typedef struct {
....................    void * buffer;
....................    int push_count;
....................    int pop_count;
....................    int size;
....................    int element_size;
.................... } circbuf_t;
.................... 
.................... #define __CIRCBUF_VAR_DEF(type, buf, sz)  \
....................    type buf ## _circbuf_data[sz];         \
....................    circbuf_t buf= {              \
....................       buf ## _circbuf_data,      \
....................       0,                         \
....................       0,                         \
....................       sz,                        \
....................       sizeof(type)               \
....................    };
.................... 
.................... //!#define __CIRCBUF_VAR_DEF(type, buf, sz)      \
.................... //!   type buf ## _circbuf_data[sz];         \
.................... //!   circbuf_t buf= {            \
.................... //!      .buffer = buf ## _circbuf_data,      \
.................... //!      .push_count = 0,         \
.................... //!      .pop_count = 0,            \
.................... //!      .size = sz,            \
.................... //!      .element_size = sizeof(type)      \
.................... //!   };
.................... //!
.................... 
.................... int __circbuf_push(circbuf_t *circbuf, void *elem);
.................... int __circbuf_pop (circbuf_t *circbuf, void *elem, int read_only);
.................... int __circbuf_free_space(circbuf_t *circbuf);
.................... /* -------------------------------------------------------------------------- */
.................... 
.................... /**
....................  * Description:
....................  *   Zero slots in circular buffer after a pop.
....................  */
.................... // #define CIRCBUF_CLEAN_ON_POP
.................... 
.................... /**
....................  * Description:
....................  *   Defines a global circular buffer `buf` of a given type and size. The type
....................  *   can be native data types or user-defined data types.
....................  *
....................  * Usage:
....................  *   CIRCBUF_DEF(uint8_t, byte_buf, 13);
....................  *   CIRCBUF_DEF(struct foo, foo_buf, 10);
....................  */
.................... #define CIRCBUF_DEF(type, buf, size)         \
....................    __CIRCBUF_VAR_DEF(type, buf, size)      \
....................    int buf ## _push_refd(type *pt)         \
....................    {                  \
....................       return __circbuf_push(&buf, pt);   \
....................    }                  \
....................    int buf ## _pop_refd(type *pt)         \
....................    {                  \
....................       return __circbuf_pop(&buf, pt, 0);   \
....................    }                  \
....................    int buf ## _peek_refd(type *pt)         \
....................    {                  \
....................       return __circbuf_pop(&buf, pt, 1);   \
....................    }
.................... 
.................... /**
....................  * Description:
....................  *   Resets the circular buffer offsets to zero. Does not clean the newly freed
....................  *   slots.
....................  */
.................... #define CIRCBUF_FLUSH(buf)            \
....................    do {                  \
....................       buf.push_count = 0;         \
....................       buf.pop_count = 0;         \
....................    } while(0)
.................... 
.................... /**
....................  * Description:
....................  *   Pushes element pointed to by `elem` at the head of circular buffer `buf`.
....................  *   This is read-write method, occupancy count increases by one.
....................  *
....................  * Returns (int):
....................  *   0 - Success
....................  *  -1 - Out of space
....................  */
.................... #define CIRCBUF_PUSH(buf, elem)             buf ## _push_refd(elem)
.................... 
.................... /**
....................  * Description:
....................  *   Copies the element at tail of circular buffer `buf` into location pointed
....................  *   by `elem`. This method is read-only, does not alter occupancy status.
....................  *
....................  * Returns (int):
....................  *   0 - Success
....................  *  -1 - Empty
....................  */
.................... #define CIRCBUF_PEEK(buf, elem)             buf ## _peek_refd(elem)
.................... 
.................... /**
....................  * Description:
....................  *   Removes the element at tail from circular buffer `buf` and makes it
....................  *   available at `elem`. This is read-write method, occupancy count reduces
....................  *   by one.
....................  *
....................  * Returns (int):
....................  *   0 - Success
....................  *  -1 - Empty
....................  */
.................... #define CIRCBUF_POP(buf, elem)              buf ## _pop_refd(elem)
.................... 
.................... /**
....................  * Description:
....................  *   Returns the number of free slots in the circular buffer `buf`.
....................  *
....................  * Returns (int):
....................  *   0..N - number of slots available.
....................  */
.................... #define CIRCBUF_FS(buf)                     __circbuf_free_space(&buf)
.................... 
.................... #endif /* _UTIL_CIRCBUF_H_ */
.................... 
.................... 
.................... int __circbuf_pop(circbuf_t *circ_buf, void *elem, int read_only)
.................... {
....................    int16_t total;
....................    char *tail;
.................... 
....................    total = circ_buf->push_count - circ_buf->pop_count;
*
00262:  MOVLW  02
00264:  MOVLB  6
00266:  ADDWF  xAD,W
00268:  MOVWF  4E9
0026A:  MOVLW  00
0026C:  ADDWFC xAE,W
0026E:  MOVWF  4EA
00270:  MOVFF  4EF,6B6
00274:  MOVLW  03
00276:  ADDWF  xAD,W
00278:  MOVWF  4E9
0027A:  MOVLW  00
0027C:  ADDWFC xAE,W
0027E:  MOVWF  4EA
00280:  MOVF   4EF,W
00282:  SUBWF  xB6,W
00284:  MOVWF  xB2
00286:  CLRF   xB3
....................    if (total < 0)
00288:  BTFSS  xB3.7
0028A:  BRA    02A8
....................       total += (2 * circ_buf->size);
0028C:  MOVLW  04
0028E:  ADDWF  xAD,W
00290:  MOVWF  4E9
00292:  MOVLW  00
00294:  ADDWFC xAE,W
00296:  MOVWF  4EA
00298:  MOVFF  4EF,500
0029C:  BCF    4D8.0
0029E:  RLCF   500,F
002A0:  MOVF   500,W
002A2:  ADDWF  xB2,F
002A4:  MOVLW  00
002A6:  ADDWFC xB3,F
.................... 
....................    if (total == 0)
002A8:  MOVF   xB2,F
002AA:  BNZ   02B6
002AC:  MOVF   xB3,F
002AE:  BNZ   02B6
....................       return -1; // Empty
002B0:  MOVLW  FF
002B2:  MOVWF  501
002B4:  BRA    038C
.................... 
....................    tail = (char *)circ_buf->buffer + ((circ_buf->pop_count % circ_buf->size)
....................          * circ_buf->element_size);
002B6:  MOVFF  6AD,4E9
002BA:  MOVFF  6AE,4EA
002BE:  MOVFF  4EC,6B7
002C2:  MOVF   4ED,F
002C4:  MOVFF  4EF,6B6
002C8:  MOVLW  03
002CA:  ADDWF  xAD,W
002CC:  MOVWF  4E9
002CE:  MOVLW  00
002D0:  ADDWFC xAE,W
002D2:  MOVWF  4EA
002D4:  MOVFF  4EF,6BA
002D8:  MOVLW  04
002DA:  ADDWF  xAD,W
002DC:  MOVWF  4E9
002DE:  MOVLW  00
002E0:  ADDWFC xAE,W
002E2:  MOVWF  4EA
002E4:  MOVFF  4EF,6BB
002E8:  MOVLB  0
002EA:  RCALL  00B4
002EC:  MOVLW  05
002EE:  MOVLB  6
002F0:  ADDWF  xAD,W
002F2:  MOVWF  4E9
002F4:  MOVLW  00
002F6:  ADDWFC xAE,W
002F8:  MOVWF  4EA
002FA:  MOVF   4EF,W
002FC:  MULWF  500
002FE:  MOVF   4F3,W
00300:  ADDWF  xB6,W
00302:  MOVWF  xB4
00304:  MOVLW  00
00306:  ADDWFC xB7,W
00308:  MOVWF  xB5
.................... 
....................    if (elem)
0030A:  MOVF   xAF,W
0030C:  IORWF  xB0,W
0030E:  BZ    033E
....................       memcpy(elem, tail, circ_buf->element_size);
00310:  MOVLW  05
00312:  ADDWF  xAD,W
00314:  MOVWF  4E9
00316:  MOVLW  00
00318:  ADDWFC xAE,W
0031A:  MOVWF  4EA
0031C:  MOVFF  4EF,6B6
00320:  MOVFF  6B0,4EA
00324:  MOVFF  6AF,4E9
00328:  MOVFF  6B5,4E2
0032C:  MOVFF  6B4,4E1
00330:  MOVF   xB6,W
00332:  MOVWF  501
00334:  BZ    033E
00336:  MOVFF  4E6,4EE
0033A:  DECFSZ 501,F
0033C:  BRA    0336
.................... 
....................    if (!read_only) {
0033E:  MOVF   xB1,F
00340:  BNZ   0388
.................... #ifdef CIRCBUF_CLEAN_ON_POP
....................       memset(tail, 0, circ_buf->element_size);
.................... #endif
....................       circ_buf->pop_count++;
00342:  MOVLW  03
00344:  ADDWF  xAD,W
00346:  MOVWF  4E9
00348:  MOVLW  00
0034A:  ADDWFC xAE,W
0034C:  MOVWF  4EA
0034E:  INCF   4EF,F
....................       if (circ_buf->pop_count >= (2*circ_buf->size))
00350:  MOVLW  03
00352:  ADDWF  xAD,W
00354:  MOVWF  4E9
00356:  MOVLW  00
00358:  ADDWFC xAE,W
0035A:  MOVWF  4EA
0035C:  MOVFF  4EF,6B6
00360:  MOVLW  04
00362:  ADDWF  xAD,W
00364:  MOVWF  4E9
00366:  MOVLW  00
00368:  ADDWFC xAE,W
0036A:  MOVWF  4EA
0036C:  MOVFF  4EF,500
00370:  BCF    4D8.0
00372:  RLCF   500,F
00374:  MOVF   500,W
00376:  SUBWF  xB6,W
00378:  BNC   0388
....................          circ_buf->pop_count = 0;
0037A:  MOVLW  03
0037C:  ADDWF  xAD,W
0037E:  MOVWF  4E9
00380:  MOVLW  00
00382:  ADDWFC xAE,W
00384:  MOVWF  4EA
00386:  CLRF   4EF
....................    }
....................    return 0;
00388:  MOVLW  00
0038A:  MOVWF  501
0038C:  MOVLB  0
0038E:  GOTO   03AA (RETURN)
.................... }
.................... 
.................... int __circbuf_push(circbuf_t *circ_buf, void *elem)
.................... {
....................    int16_t total;
....................    char *head;
.................... 
....................    total = circ_buf->push_count - circ_buf->pop_count;
*
000E0:  MOVLW  02
000E2:  MOVLB  6
000E4:  ADDWF  xAD,W
000E6:  MOVWF  4E9
000E8:  MOVLW  00
000EA:  ADDWFC xAE,W
000EC:  MOVWF  4EA
000EE:  MOVFF  4EF,6B5
000F2:  MOVLW  03
000F4:  ADDWF  xAD,W
000F6:  MOVWF  4E9
000F8:  MOVLW  00
000FA:  ADDWFC xAE,W
000FC:  MOVWF  4EA
000FE:  MOVF   4EF,W
00100:  SUBWF  xB5,W
00102:  MOVWF  xB1
00104:  CLRF   xB2
....................    if (total < 0)
00106:  BTFSS  xB2.7
00108:  BRA    0126
....................       total += (2 * circ_buf->size);
0010A:  MOVLW  04
0010C:  ADDWF  xAD,W
0010E:  MOVWF  4E9
00110:  MOVLW  00
00112:  ADDWFC xAE,W
00114:  MOVWF  4EA
00116:  MOVFF  4EF,500
0011A:  BCF    4D8.0
0011C:  RLCF   500,F
0011E:  MOVF   500,W
00120:  ADDWF  xB1,F
00122:  MOVLW  00
00124:  ADDWFC xB2,F
.................... 
....................    if (total >=  circ_buf->size)
00126:  MOVLW  04
00128:  ADDWF  xAD,W
0012A:  MOVWF  4E9
0012C:  MOVLW  00
0012E:  ADDWFC xAE,W
00130:  MOVWF  4EA
00132:  MOVF   4EF,W
00134:  BTFSC  xB2.7
00136:  BRA    0146
00138:  MOVF   xB2,F
0013A:  BNZ   0140
0013C:  SUBWF  xB1,W
0013E:  BNC   0146
....................       return -1; // Full
00140:  MOVLW  FF
00142:  MOVWF  501
00144:  BRA    0212
.................... 
....................    head = (char *)circ_buf->buffer + ( (circ_buf->push_count % circ_buf->size)
....................          * circ_buf->element_size );
00146:  MOVFF  6AD,4E9
0014A:  MOVFF  6AE,4EA
0014E:  MOVFF  4EC,6B6
00152:  MOVF   4ED,F
00154:  MOVFF  4EF,6B5
00158:  MOVLW  02
0015A:  ADDWF  xAD,W
0015C:  MOVWF  4E9
0015E:  MOVLW  00
00160:  ADDWFC xAE,W
00162:  MOVWF  4EA
00164:  MOVFF  4EF,6BA
00168:  MOVLW  04
0016A:  ADDWF  xAD,W
0016C:  MOVWF  4E9
0016E:  MOVLW  00
00170:  ADDWFC xAE,W
00172:  MOVWF  4EA
00174:  MOVFF  4EF,6BB
00178:  MOVLB  0
0017A:  RCALL  00B4
0017C:  MOVLW  05
0017E:  MOVLB  6
00180:  ADDWF  xAD,W
00182:  MOVWF  4E9
00184:  MOVLW  00
00186:  ADDWFC xAE,W
00188:  MOVWF  4EA
0018A:  MOVF   4EF,W
0018C:  MULWF  500
0018E:  MOVF   4F3,W
00190:  ADDWF  xB5,W
00192:  MOVWF  xB3
00194:  MOVLW  00
00196:  ADDWFC xB6,W
00198:  MOVWF  xB4
....................    memcpy(head, elem, circ_buf->element_size);
0019A:  MOVLW  05
0019C:  ADDWF  xAD,W
0019E:  MOVWF  4E9
001A0:  MOVLW  00
001A2:  ADDWFC xAE,W
001A4:  MOVWF  4EA
001A6:  MOVFF  4EF,6B5
001AA:  MOVFF  6B4,4EA
001AE:  MOVFF  6B3,4E9
001B2:  MOVFF  6B0,4E2
001B6:  MOVFF  6AF,4E1
001BA:  MOVF   xB5,W
001BC:  MOVWF  501
001BE:  BZ    01C8
001C0:  MOVFF  4E6,4EE
001C4:  DECFSZ 501,F
001C6:  BRA    01C0
....................    circ_buf->push_count++;
001C8:  MOVLW  02
001CA:  ADDWF  xAD,W
001CC:  MOVWF  4E9
001CE:  MOVLW  00
001D0:  ADDWFC xAE,W
001D2:  MOVWF  4EA
001D4:  INCF   4EF,F
....................    if (circ_buf->push_count >= (2*circ_buf->size))
001D6:  MOVLW  02
001D8:  ADDWF  xAD,W
001DA:  MOVWF  4E9
001DC:  MOVLW  00
001DE:  ADDWFC xAE,W
001E0:  MOVWF  4EA
001E2:  MOVFF  4EF,6B5
001E6:  MOVLW  04
001E8:  ADDWF  xAD,W
001EA:  MOVWF  4E9
001EC:  MOVLW  00
001EE:  ADDWFC xAE,W
001F0:  MOVWF  4EA
001F2:  MOVFF  4EF,500
001F6:  BCF    4D8.0
001F8:  RLCF   500,F
001FA:  MOVF   500,W
001FC:  SUBWF  xB5,W
001FE:  BNC   020E
....................       circ_buf->push_count = 0;
00200:  MOVLW  02
00202:  ADDWF  xAD,W
00204:  MOVWF  4E9
00206:  MOVLW  00
00208:  ADDWFC xAE,W
0020A:  MOVWF  4EA
0020C:  CLRF   4EF
....................    return 0;
0020E:  MOVLW  00
00210:  MOVWF  501
00212:  MOVLB  0
00214:  GOTO   022E (RETURN)
.................... }
.................... 
.................... int __circbuf_free_space(circbuf_t *circ_buf)
.................... {
....................    int16_t total;
.................... 
....................    total = circ_buf->push_count - circ_buf->pop_count;
....................    if (total < 0)
....................       total += (2 * circ_buf->size);
.................... 
....................    return circ_buf->size - total;
.................... }
.................... 
.................... 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_C7,rcv=PIN_C6,bits=8,stream=RS232_U1,UART1,RECEIVE_BUFFER=2,errors)
.................... 
.................... #use rtos(timer=0,minor_cycle=1ms)
.................... 
.................... #task(rate=1000ms,max=1ms,enabled=TRUE)
.................... int16_t application();
.................... 
.................... CIRCBUF_DEF(can_rx_frame_t, my_circ_buf, 32)
00218:  MOVLW  06
0021A:  MOVLB  6
0021C:  MOVWF  xAE
0021E:  MOVLW  8D
00220:  MOVWF  xAD
00222:  MOVFF  6AC,6B0
00226:  MOVFF  6AB,6AF
0022A:  MOVLB  0
0022C:  BRA    00E0
0022E:  MOVF   501,W
00230:  GOTO   0444 (RETURN)
*
00392:  MOVLW  06
00394:  MOVLB  6
00396:  MOVWF  xAE
00398:  MOVLW  8D
0039A:  MOVWF  xAD
0039C:  MOVFF  6AC,6B0
003A0:  MOVFF  6AB,6AF
003A4:  CLRF   xB1
003A6:  MOVLB  0
003A8:  BRA    0262
003AA:  MOVF   501,W
003AC:  GOTO   046C (RETURN)
.................... 
.................... 
.................... //!can_rx_frame_t my_circ_buf_circbuf_data[32]; 
.................... //!circbuf_t my_circ_buf = { 
.................... //!    my_circ_buf_circbuf_data, 
.................... //!    0, 
.................... //!    0, 
.................... //!    32, 
.................... //!    sizeof(can_rx_frame_t) 
.................... //!}; 
.................... //!int my_circ_buf_push_refd(can_rx_frame_t *pt) { 
.................... //!    return __circbuf_push(&my_circ_buf, pt); 
.................... //!}
.................... //!int my_circ_buf_pop_refd(can_rx_frame_t *pt) { 
.................... //!    return __circbuf_pop(&my_circ_buf, pt, 0); 
.................... //!} 
.................... //!int my_circ_buf_peek_refd(can_rx_frame_t *pt) { 
.................... //!    return __circbuf_pop(&my_circ_buf, pt, 1); 
.................... //!};
.................... //!
.................... 
.................... 
.................... int16_t application()
.................... {
....................     can_rx_frame_t in_frame;
....................     can_rx_frame_t out_frame;
....................     
....................     in_frame.can_header = 1;
*
00430:  MOVLW  01
00432:  MOVLB  6
00434:  MOVWF  x95
....................     out_frame.can_header = 0; //overwrite me
00436:  CLRF   xA0
.................... 
....................     if (my_circ_buf_push_refd(&in_frame)) {
00438:  MOVLW  06
0043A:  MOVWF  xAC
0043C:  MOVLW  95
0043E:  MOVWF  xAB
00440:  MOVLB  0
00442:  BRA    0218
00444:  MOVF   501,F
00446:  BZ    045E
....................         printf("Out of space in CB\n");
00448:  MOVLW  FA
0044A:  MOVWF  4F6
0044C:  MOVLW  04
0044E:  MOVWF  4F7
00450:  MOVLW  00
00452:  MOVWF  4F8
00454:  RCALL  0234
....................         return -1;
00456:  MOVLW  FF
00458:  MOVWF  501
0045A:  MOVWF  502
0045C:  BRA    04EA
....................     }
.................... 
....................     if (my_circ_buf_pop_refd(&out_frame)) {
0045E:  MOVLW  06
00460:  MOVLB  6
00462:  MOVWF  xAC
00464:  MOVLW  A0
00466:  MOVWF  xAB
00468:  MOVLB  0
0046A:  BRA    0392
0046C:  MOVF   501,F
0046E:  BZ    0486
....................         printf("CB is empty\n");
00470:  MOVLW  0E
00472:  MOVWF  4F6
00474:  MOVLW  05
00476:  MOVWF  4F7
00478:  MOVLW  00
0047A:  MOVWF  4F8
0047C:  RCALL  0234
....................         return -1;
0047E:  MOVLW  FF
00480:  MOVWF  501
00482:  MOVWF  502
00484:  BRA    04EA
....................     }
.................... 
....................     // here is the data
....................     printf("Push: 0x%x\n", in_frame.can_header);
00486:  MOVLW  1C
00488:  MOVWF  4F6
0048A:  MOVLW  05
0048C:  MOVWF  4F7
0048E:  MOVLW  00
00490:  MOVWF  4F8
00492:  MOVLW  08
00494:  MOVLB  6
00496:  MOVWF  xAB
00498:  MOVLB  0
0049A:  RCALL  03B0
0049C:  MOVFF  695,6AB
004A0:  MOVLW  57
004A2:  MOVLB  6
004A4:  MOVWF  xAC
004A6:  MOVLB  0
004A8:  RCALL  03E4
004AA:  MOVLW  0A
004AC:  BTFSS  4B2.1
004AE:  BRA    04AC
004B0:  MOVLB  2
004B2:  MOVWF  xA3
....................     printf("Pop:  0x%x\n", out_frame.can_header);
004B4:  MOVLW  28
004B6:  MOVWF  4F6
004B8:  MOVLW  05
004BA:  MOVWF  4F7
004BC:  MOVLW  00
004BE:  MOVWF  4F8
004C0:  MOVLW  08
004C2:  MOVLB  6
004C4:  MOVWF  xAB
004C6:  MOVLB  0
004C8:  RCALL  03B0
004CA:  MOVFF  6A0,6AB
004CE:  MOVLW  57
004D0:  MOVLB  6
004D2:  MOVWF  xAC
004D4:  MOVLB  0
004D6:  RCALL  03E4
004D8:  MOVLW  0A
004DA:  BTFSS  4B2.1
004DC:  BRA    04DA
004DE:  MOVLB  2
004E0:  MOVWF  xA3
....................     return 0;
004E2:  MOVLW  00
004E4:  MOVWF  501
004E6:  MOVWF  502
004E8:  MOVLB  0
004EA:  MOVLW  30
004EC:  MOVWF  52A
004EE:  MOVLW  04
004F0:  MOVWF  52B
004F2:  MOVLW  00
004F4:  MOVWF  52C
004F6:  GOTO   066C
.................... }
.................... 
.................... 
.................... void main()
*
00534:  CLRF   4F8
00536:  BCF    4D6.5
00538:  BSF    507.7
0053A:  MOVLB  E
0053C:  MOVLW  55
0053E:  MOVLB  2
00540:  MOVWF  x00
00542:  MOVLW  AA
00544:  MOVWF  x00
00546:  BCF    x00.0
00548:  MOVLW  16
0054A:  MOVWF  x72
0054C:  MOVLW  20
0054E:  MOVWF  x18
00550:  MOVLW  55
00552:  MOVWF  x00
00554:  MOVLW  AA
00556:  MOVWF  x00
00558:  BSF    x00.0
0055A:  MOVLB  0
0055C:  CLRF   xB0
0055E:  CLRF   xAF
00560:  CLRF   xB3
00562:  MOVLW  08
00564:  MOVWF  xB1
00566:  MOVLW  60
00568:  MOVWF  xAD
0056A:  MOVLB  2
0056C:  BCF    xAC.7
0056E:  BCF    4C8.7
00570:  BSF    4C0.7
00572:  MOVLW  B0
00574:  MOVWF  xAB
00576:  CLRF   xAF
00578:  MOVLW  8A
0057A:  MOVWF  xAE
0057C:  CLRF   xAD
0057E:  BSF    xAC.7
00580:  CLRF   51F
00582:  CLRF   520
00584:  CLRF   522
00586:  CLRF   521
00588:  CLRF   523
0058A:  CLRF   51F
0058C:  CLRF   520
0058E:  BSF    4A2.0
00590:  MOVLB  6
00592:  CLRF   x94
00594:  CLRF   x93
00596:  MOVLB  4
00598:  CLRF   x00
0059A:  CLRF   x08
0059C:  CLRF   x10
0059E:  CLRF   x18
005A0:  CLRF   x20
005A2:  CLRF   x28
005A4:  MOVLB  0
005A6:  CLRF   x71
005A8:  CLRF   x72
005AA:  CLRF   x73
005AC:  CLRF   x70
005AE:  CLRF   x75
005B0:  CLRF   x76
005B2:  CLRF   x77
005B4:  CLRF   x74
005B6:  CLRF   51B
005B8:  CLRF   51C
005BA:  MOVLW  05
005BC:  MOVLB  6
005BE:  MOVWF  x8E
005C0:  MOVLW  2D
005C2:  MOVWF  x8D
005C4:  CLRF   x8F
005C6:  CLRF   x90
005C8:  MOVLW  20
005CA:  MOVWF  x91
005CC:  MOVLW  0B
005CE:  MOVWF  x92
.................... {
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_1|RTCC_8_BIT);      //16.0 us overflow
005D0:  MOVLW  80
005D2:  MOVLB  3
005D4:  MOVWF  x1A
005D6:  MOVLW  40
005D8:  MOVWF  x1B
....................    while(TRUE)
....................    {
....................       rtos_run ( );
005DA:  CLRF   525
005DC:  MOVLW  03
005DE:  MOVWF  527
005E0:  MOVLW  E8
005E2:  MOVWF  526
005E4:  CLRF   529
005E6:  CLRF   528
005E8:  MOVLW  30
005EA:  MOVWF  52A
005EC:  MOVLW  04
005EE:  MOVWF  52B
005F0:  MOVLW  00
005F2:  MOVWF  52C
005F4:  CLRF   524
005F6:  MOVLW  90
005F8:  MOVWF  x1A
005FA:  MOVLW  40
005FC:  MOVWF  x1B
005FE:  BTFSS  x1A.4
00600:  BRA    0606
00602:  MOVLW  C1
00604:  MOVWF  x19
00606:  MOVLW  80
00608:  MOVWF  x18
0060A:  BCF    4B1.7
0060C:  BCF    4D8.0
0060E:  RLCF   524,W
00610:  MOVWF  500
00612:  MOVLB  0
00614:  RCALL  005C
00616:  MOVWF  502
00618:  MOVLW  01
0061A:  ADDWF  500,W
0061C:  RCALL  005C
0061E:  MOVWF  503
00620:  MOVFF  503,4EA
00624:  MOVFF  502,4E9
00628:  MOVFF  4EF,502
0062C:  INCF   4E9,F
0062E:  MOVFF  4EF,500
00632:  MOVFF  4EC,501
00636:  INCF   4EC,F
00638:  MOVFF  4EF,503
0063C:  BNZ   0642
0063E:  INCF   4EC,F
00640:  MOVF   4ED,F
00642:  MOVF   4EC,W
00644:  SUBWF  501,W
00646:  BNZ   066E
00648:  MOVF   500,W
0064A:  SUBWF  503,W
0064C:  BNZ   066E
0064E:  MOVF   4ED,F
00650:  CLRF   4EE
00652:  CLRF   4EF
00654:  BTFSC  502.7
00656:  BRA    066E
00658:  MOVF   4EC,F
0065A:  MOVFF  4EC,4FA
0065E:  MOVFF  4EC,4FB
00662:  MOVF   4ED,F
00664:  MOVF   4ED,F
00666:  MOVFF  4EF,4E8
0066A:  MOVWF  4F9
0066C:  MOVLB  0
0066E:  INCF   524,F
00670:  MOVLW  01
00672:  SUBWF  524,W
00674:  BTFSC  4D8.2
00676:  BRA    067C
00678:  MOVLB  3
0067A:  BRA    060C
0067C:  CLRF   524
0067E:  MOVLB  3
00680:  MOVF   x18,W
00682:  BTFSC  x1A.4
00684:  MOVFF  319,503
00688:  BTFSS  x1A.4
0068A:  CLRF   503
0068C:  BTFSC  4B1.7
0068E:  BRA    05FE
00690:  BRA    0680
00692:  SETF   524
00694:  BRA    05DA
....................    }
.................... }
00696:  BRA    0696

Configuration Fuses:
   Word  1: EF8C   NOEXTOSC RSTOSC_HFINTRC_64MHZ NOCLKOUT PRLOCK1WAY CKS NOJTAG FCMEN PFCMEN SFCMEN
   Word  2: CF37   MCLR NOPUT NOMVECEN IVT1WAY NOLPBOR NOBROWNOUT BORV19 ZCDDIS PPS1WAY NOSTVREN NOLVP NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: FFDF   BBSIZ512 NOBOOTBLOCK NOSAF DEBUG NOWRTB NOWRTC NOWRTD NOWRTSAF NOWRT
   Word  5: FFFF   CRCBOOTPINC5 NOCRCBOOTPIN CRCBOOTPIN_DRIVEN NOPROTECT
   Word  6: FFFF   NOCRCSCANBB CRCBBSCANERR_STOP NOCRCSCANAPP NOCRCSCANSAF NOCRCSCANEE NOCRCSCANCONFIG NOCRCBOOTSCAN
   Word  7: FFFF  
   Word  8: FFFF  
   Word  9: FFFF  
   Word 10: FFFF  
   Word 11: FFFF  
   Word 12: FFFF  
   Word 13: FFFF  
   Word 14: FFFF  
   Word 15: FFFF  
   Word 16: FFFF  
   Word 17: FFFF  
   Word 18: FFFF  

   Some fuses have been forced to be compatible with the ICD debugger.
